#### 앱 프로그래밍 기초 10주차



##### 객체 지향 프로그래밍(Oject Priented Programming)



##### 객체 지향 프로그래밍이란?

* ###### 객체지향 프로그래밍(Object Oriented Programming: OOP)은 **프로그램을 '객체'라는 독립된 단위로**
* 
**###### &nbsp;     나누어, 이 객체들이 서로 상호작용하며 동작하도록 설계하는 프로그래밍 패러다임**



###### **현실 세계의 사물이나 개념을 모델링 해 객체로 표현하는 방식임**





##### **OOP핵심 개념**

1. ###### **객체(개체)(Object)**

* **현실 세계의 사물이나 개념을 코드로 표현한 것. 예: 자동차,학생,은행 계좌 등**
* 
**###### 2\. 클래스(Class)**

* **객체를 만들기 위한 설계도. 객체의 속성(변수)과 행동(메서드)을 정의.**
* 
**###### 3\. 인스턴스(Instance)**

* **클래스 기반으로 실제로 생성된 객체.**
* 
**###### 4\. 속성(Attribute)**

* **객체가 가진 데이터(예: 자동차의 색상, 속도)**
* 
**###### 5\. 메서드(Method)**

* **객체가 수행할 수 있는 행동(예: 자동차 accelerate, brake).**











##### **OOP 4대원칙**



###### **캡슐화 Encapsulation**

**-데이터 기능을 하나로 묶고, 외부에서 접근하지 못하게 보호**

**(예: 사생활 보호)**



###### 상속 Inheritance

\-기존 클래스의 속성과 기능을 물려 받아 새로운 클래스로  정의

(예: 부모 재산 상속)



###### 다형성 Polymorphism

\-같은 이름의 메서드가 상황에 따라 다르게 동작

(예: 이동 - 기다,걷다,뛰다,날다)



###### 추상화 Abstraction

\-복잡한 구현으ㄹ 숨기고, 필요한 기능만 드러냄

(예:Auto 기어 자동차 운전)







##### OOP를 왜 써야 하는가?

1. ###### 소프트웨어가 복잡해도, 객체 단위로 나누어 서로 상호작용하게 만들면 구조가 단순해지고, 

###### 효율적이며 유지보수가 쉬워진다.

###### 2\. 프로그램을 여러 객체로 나누어 표현하면, 각 객체가 맡은 역할만 관리하면 되기 때문에

###### 개발과 유지보수가 훨씬 편리 해진다









##### Dart에서 OOP

* ###### 클래스
* 하나의 독립된 기능과 상태를 가지는 단위를 객체로 모델링 한것이 **클래스**
* ###### 생성자
* 클래스를 이용해 인스턴스 생성하는 방법이 **생성자**

&nbsp;     - 명명된 생성자

&nbsp;     -  팩토리 생성자

* ###### 변수

&nbsp;     - 멤버 변수

* 객체의 상태가 **멤버  변수(필드).**

&nbsp;     - 클래스 변수

* 클래스 공토으로 접근 되는 변수가 **클래스 변수**
* ###### 멤버 함수
* \- 클래스 객체를 생성한 것이 인스턴스
* ###### 4대 원칙

&nbsp;     - 상속

* "부모의 재능과 성격을 자식이 이어받는 것"

&nbsp;     - 캡술화

"카페에서 커피 주문하면, 바리스타가 어떻게 만드는 지는 몰라도 결과만 받으면 된다."

&nbsp;     - 추상화

"밥은 숟가락으로 먹든 젓가락으로 먹든, 결국 '먹는다'라는 행위만 중요하다"

&nbsp;     - 다형성

"스마트폰의 '재생버튼'을 누르면 음악, 영상, 팟캐스트 등 상황에 따라 다른 콘텐츠가 실행된다"

* mixin

"게임 캐릭타에 '날개 아이템'을 장착하면, 원래 종족과 상관없이 누구나 날 수 있다"







##### 객체지향에서 캡슐화가 적용안된 코드와 잘 적용된 코드

###### 객체지향에서 캡슐화(Encapsulation)란 객체의 내부 구현(데이터, 로직)을 외부에서 직접 접근하지 못하게 숨기고,

###### 필요한 기능만 메서드를 통해 제공하는 원칙이다



###### X 캡슐화가 적용되지 않는 코드(잘못예시)

###### 다트 언어



class BankAccount {

&nbsp; String owner;   // 누구나 접근 가능

&nbsp; double balance; // 누구나 접근 가능



&nbsp; BankAccount(this.owner, this.balance);

}



void main() {

&nbsp; var account = BankAccount("홍길동", 1000);

&nbsp; account.balance = -500; // 잘못된 값도 직접 넣을 수 있음

&nbsp; print("${account.owner}님의 잔액: ${account.balance}");

}



문제점:

* balance를 외부에서 직접 수정할 수 있음
* 음수 잔액 같은 잘못된 상태가 쉽게 발생할 수 있다
* 데이터 무결성이 깨짐





캡슐화가 잘 적용된 코드(올바른 예시)

class BankAccount {

&nbsp; String \_owner;   // private (언더스코어 사용)

&nbsp; double \_balance; // private



&nbsp; BankAccount(this.\_owner, double initialBalance) {

&nbsp;   \_balance = initialBalance >= 0 ? initialBalance : 0;

&nbsp; }



&nbsp; // getter

&nbsp; String get owner => \_owner;

&nbsp; double get balance => \_balance;



&nbsp; // 메서드를 통해서만 값 변경

&nbsp; void deposit(double amount) {

&nbsp;   if (amount > 0) {

&nbsp;     \_balance += amount;

&nbsp;   }

&nbsp; }



&nbsp; void withdraw(double amount) {

&nbsp;   if (amount > 0 \&\& \_balance >= amount) {

&nbsp;     \_balance -= amount;

&nbsp;   }

&nbsp; }

}



void main() {

&nbsp; var account = BankAccount("홍길동", 1000);

&nbsp; account.deposit(500);   // 올바른 방식으로 입금

&nbsp; account.withdraw(200);  // 올바른 방식으로 출금

&nbsp; print("${account.owner}님의 잔액: ${account.balance}");

}



장점:

* -balance와 \_owner는 외부에서 직접 접근 불가
* 반드시 deposit과 withdraw 메서드만 통해서만 변경 가능
* 잘못된 값 입력을 방지하고 객체의 무결성 보장

Dat에서는 언더스코어(\_)를 붙여서 클래스 내부에서 private변수를 만들고 외부에는 getter/setter 또는 메서드를 통해 접근하도록 제한 하는 방식으로 캡슐화를 구현한다









##### 실습 다트코드 (예시)

class Animal {

&nbsp; String name;

&nbsp; 

&nbsp; Animal(this.name);

&nbsp; 

&nbsp; void makeSound() {

&nbsp;   print("$name이(가) 소리를 냅니다.");

&nbsp; }

}



void main() {

&nbsp; Animal a1 = Animal("아무개");

&nbsp; a1.makeSound();

}



출력

아무개이(가) 소리를 냅니다.







class Animal {

&nbsp; String name;

&nbsp; 

&nbsp; Animal(this.name);

&nbsp; 

&nbsp; void makeSound() {

&nbsp;   print("$name이(가) 소리를 냅니다.");

&nbsp; }

}



void main() {

&nbsp; Animal a1 = Animal("아무개");

&nbsp; Animal a2 = Animal("아무고양이");

&nbsp; a1.makeSound();

&nbsp; a1.makeSound();

&nbsp; 

&nbsp; List<Animal> animals = \[a1, a2];

&nbsp; for (var i = 0; i < animals.length; i++) {

&nbsp;   animals\[i].makeSound();

&nbsp; }

}





출력

아무개이(가) 소리를 냅니다.

아무개이(가) 소리를 냅니다.

아무개이(가) 소리를 냅니다.

아무고양이이(가) 소리를 냅니다.









class Animal {

&nbsp; String name;

&nbsp; 

&nbsp; Animal(this.name);

&nbsp; 

&nbsp; void makeSound() {

&nbsp;   print("$name이(가) 소리를 냅니다.");

&nbsp; }

}



class Cat extends Animal {

&nbsp; Cat(String name) : super(name);

&nbsp; 

&nbsp; @override

&nbsp; void makeSound() {

&nbsp;   print("$name: 냐옹!");

&nbsp; }

}



class Dog extends Animal {

&nbsp; Dog(String name) : super(name);

&nbsp; 

&nbsp; @override

&nbsp; void makeSound() {

&nbsp;   print("$name: 멍멍!");

&nbsp; }

}



class Duck extends Animal {

&nbsp; Duck(String name) : super(name);

&nbsp; 

&nbsp; @override

&nbsp; void makeSound() {

&nbsp;   print("$name: 꽥꽥!");

&nbsp; }

}

void main() {

&nbsp; List<Animal> animals = \[

&nbsp;   Cat("냐옹이"),

&nbsp;   Cat("검둥고양"),

&nbsp;   Dog("꽁치"),

&nbsp;   Dog("도미"),

&nbsp;   Duck("오리삼촌"),

&nbsp;   Duck("오리아이1"),

&nbsp;   Duck("오리아이2"),

&nbsp; ];

&nbsp; 

&nbsp; for (var animal in animals) {

&nbsp;   animal.makeSound();

&nbsp; }

&nbsp; 

//  Animal a1 = Animal("아무개");

//  Animal a2 = Animal("아무고양이");

//  a1.makeSound();

//  a1.makeSound();

&nbsp; 

//  List<Animal> animals = \[a1, a2];

//  for (var i = 0; i < animals.length; i++) {

//    animals\[i].makeSound();

// }

}





출력

냐옹이: 냐옹!

검둥고양: 냐옹!

꽁치: 멍멍!

도미: 멍멍!

오리삼촌: 꽥꽥!

오리아이1: 꽥꽥!

오리아이2: 꽥꽥!



